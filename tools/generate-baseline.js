/**
 * @fileoverview Extracts CSS features from the web-features package and writes
 * them to a file.
 * See example output from web-features: https://gist.github.com/nzakas/5bbc9eab6900d1e401208fa7bcf49500
 * @author Nicholas C. Zakas
 */

//------------------------------------------------------------------------------
// Imports
//------------------------------------------------------------------------------

import { features } from "web-features";
import fs from "node:fs";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const BASELINE_HIGH = 10;
const BASELINE_LOW = 5;
const BASELINE_FALSE = 0;
const baselineIds = new Map([
	["high", BASELINE_HIGH],
	["low", BASELINE_LOW],
	[false, BASELINE_FALSE],
]);

/**
 * Filters out non-CSS features and minimizes the data.
 * @param {[string, Object]} entry The entry to filter.
 * @returns {boolean} True if the entry is a CSS feature, false otherwise.
 */
function filterCSSFeatures([, value]) {
	return value.compat_features?.some(feature => feature.startsWith("css."));
}

/**
 * Minimizes the data for a CSS feature.
 * @param {[string, Object]} entry The entry to minimize.
 * @returns {[string, Object]} The minimized entry.
 */
function minimizeData([key, value]) {
	return [
		key,
		{
			baseline: value.status.baseline,
			properties: [
				...new Set(
					value.compat_features
						.filter(feature =>
							feature.startsWith("css.properties."),
						)
						.map(feature =>
							feature
								.replace("css.properties.", "")
								.replace(/\.[\w\d-]+$/u, ""),
						),
				),
			],
			atRules: [
				...new Set(
					value.compat_features
						.filter(feature => feature.startsWith("css.at-rules."))
						.map(feature =>
							feature
								.replace("css.at-rules.", "")
								.replace(/\.[\w\d-]+$/u, ""),
						),
				),
			],
			types: [
				...new Set(
					value.compat_features
						.filter(feature => feature.startsWith("css.types."))
						.map(feature =>
							feature
								.replace("css.types.", "")
								.replace(/\.[\w\d-]+$/u, ""),
						),
				),
			],
			selectors: [
				...new Set(
					value.compat_features
						.filter(feature => feature.startsWith("css.selectors."))
						.map(feature =>
							feature
								.replace("css.selectors.", "")
								.replace(/\.[\w\d-]+$/u, ""),
						),
				),
			],
		},
	];
}

/**
 * Groups CSS features by baseline.
 * @param {Array<[string, Object]>} entries The entries to group.
 * @returns {Object} The grouped CSS features.
 */
function groupByBaseline(entries) {
	const allFeatures = {
		properties: {},
		atRules: {},
		types: {},
		selectors: {},
	};

	/*
	 * We end up with duplicates due to the naive way we are calculating
	 * which values to include. So we need to remove duplicates and update
	 * each to the highest possible baseline value.
	 */

	for (const [, value] of entries) {
		value.properties.forEach(property => {
			if (
				allFeatures.properties[property] === undefined ||
				allFeatures.properties[property] <
					baselineIds.get(value.baseline)
			) {
				allFeatures.properties[property] = baselineIds.get(
					value.baseline,
				);
			}
		});

		value.atRules.forEach(atRule => {
			if (
				allFeatures.atRules[atRule] === undefined ||
				allFeatures.atRules[atRule] < baselineIds.get(value.baseline)
			) {
				allFeatures.atRules[atRule] = baselineIds.get(value.baseline);
			}
		});

		value.types.forEach(type => {
			if (
				allFeatures.types[type] === undefined ||
				allFeatures.types[type] < baselineIds.get(value.baseline)
			) {
				allFeatures.types[type] = baselineIds.get(value.baseline);
			}
		});

		value.selectors.forEach(selector => {
			if (
				allFeatures.selectors[selector] === undefined ||
				allFeatures.selectors[selector] <
					baselineIds.get(value.baseline)
			) {
				allFeatures.selectors[selector] = baselineIds.get(
					value.baseline,
				);
			}
		});
	}

	return allFeatures;
}

//------------------------------------------------------------------------------
// Main
//------------------------------------------------------------------------------

const featuresPath = "./src/data/baseline-data.js";
const cssFeatures = groupByBaseline(
	Object.entries(features).filter(filterCSSFeatures).map(minimizeData),
);

// export each group separately as a Set, such as highProperties, lowProperties, etc.
const code = `/**
 * @fileoverview CSS features extracted from the web-features package.
 * @author tools/generate-baseline.js
 * 
 * THIS FILE IS AUTOGENERATED. DO NOT MODIFY DIRECTLY.
 */

export const BASELINE_HIGH = ${BASELINE_HIGH};
export const BASELINE_LOW = ${BASELINE_LOW};
export const BASELINE_FALSE = ${BASELINE_FALSE};

export const properties = new Map(${JSON.stringify(Object.entries(cssFeatures.properties), null, "\t")});
export const atRules = new Map(${JSON.stringify(Object.entries(cssFeatures.atRules), null, "\t")});
export const types = new Map(${JSON.stringify(Object.entries(cssFeatures.types), null, "\t")});
export const selectors = new Map(${JSON.stringify(Object.entries(cssFeatures.selectors), null, "\t")});
`;

fs.writeFileSync(featuresPath, code);
